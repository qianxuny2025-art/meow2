<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Meow Parking Jam</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Babel for in-browser JSX transformation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
      @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@300;400;500;600;700&display=swap');
      
      /* Reset & Fullscreen */
      html, body {
        margin: 0;
        padding: 0;
        width: 100vw;
        height: 100vh;
        overflow: hidden;
        background-color: #86efac;
      }

      body {
        font-family: 'Fredoka', sans-serif;
      }
      
      /* Custom pattern for grass */
      .bg-grass {
        background-color: #86efac;
        background-image: radial-gradient(#4ade80 15%, transparent 16%),
        radial-gradient(#4ade80 15%, transparent 16%);
        background-size: 60px 60px;
        background-position: 0 0, 30px 30px;
      }

      /* Hint Animations */
      @keyframes wiggle {
        0%, 100% { transform: rotate(-3deg); }
        50% { transform: rotate(3deg); }
      }
      .animate-wiggle {
        animation: wiggle 1s ease-in-out infinite;
      }
      .hint-ring {
        box-shadow: 0 0 0 4px rgba(239, 68, 68, 0.6); /* red-500 */
        animation: pulse-ring 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
      }
      @keyframes pulse-ring {
        0%, 100% { opacity: 1; transform: scale(1); }
        50% { opacity: 0; transform: scale(1.15); }
      }
    </style>

    <script type="importmap">
      {
        "imports": {
          "react": "https://esm.sh/react@18.2.0",
          "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
          "lucide-react": "https://esm.sh/lucide-react@0.263.1"
        }
      }
    </script>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
      import React, { useState, useEffect, useCallback, useRef, useMemo } from 'react';
      import { createRoot } from 'react-dom/client';
      import { RotateCcw, Volume2, VolumeX, Award, Sparkles, Trash2, Shuffle, Repeat, Play, Clock, Cat as CatIcon, Home, Pause, X, Timer } from 'lucide-react';

      // --- CONSTANTS & TYPES (JS Version) ---
      
      const Direction = {
        UP: 'UP',
        DOWN: 'DOWN',
        LEFT: 'LEFT',
        RIGHT: 'RIGHT',
      };

      const CatType = {
        NORMAL: 'NORMAL',
        BOMB: 'BOMB',
      };

      const GameState = {
        START_MENU: 'START_MENU',
        PLAYING: 'PLAYING',
        WON: 'WON',
        LOST: 'LOST',
      };

      const CELL_SIZE_PX = 26;
      const GAP_PX = 3;
      const ANIMATION_DURATION_MS = 300;
      const BOMB_TIME_SECONDS = 120;

      const CAT_SKINS = [
        'bg-slate-100',
        'bg-orange-300',
        'bg-slate-400',
        'bg-amber-200',
        'bg-stone-600',
        'bg-pink-300',
        'bg-purple-300',
        'bg-teal-300',
      ];

      const getRotationClass = (dir) => {
        switch (dir) {
          case Direction.UP: return 'rotate-0';
          case Direction.RIGHT: return 'rotate-90';
          case Direction.DOWN: return 'rotate-180';
          case Direction.LEFT: return '-rotate-90';
          default: return 'rotate-0';
        }
      };

      const getDelta = (dir) => {
        switch (dir) {
          case Direction.UP: return { dx: 0, dy: -1 };
          case Direction.DOWN: return { dx: 0, dy: 1 };
          case Direction.LEFT: return { dx: -1, dy: 0 };
          case Direction.RIGHT: return { dx: 1, dy: 0 };
          default: return { dx: 0, dy: 0 };
        }
      };

      // --- UTILS: LEVEL GENERATOR ---

      const genId = () => Math.random().toString(36).substr(2, 9);

      const getLevelConfig = (level) => {
        let size = 8;
        if (level >= 5) size = 9;
        if (level >= 10) size = 10;
        if (level >= 20) size = 11;
        
        const skinCount = Math.min(CAT_SKINS.length, 2 + Math.floor((level - 1) / 3));

        let bombChance = 0;
        if (level >= 5) bombChance = 0.05; 
        if (level >= 15) bombChance = 0.10; 
        if (level >= 30) bombChance = 0.15; 

        let unlockMsg = undefined;
        if (level === 1) unlockMsg = "Tap cats to clear!";
        else if (level === 5) unlockMsg = "âš ï¸ Bomb Cats & Bigger Grid!";
        
        return { size, skinCount, bombChance, unlockMsg };
      };

      const isValid = (x, y, size) => x >= 0 && x < size && y >= 0 && y < size;

      const getOppositeDir = (dir) => {
        switch (dir) {
          case Direction.UP: return Direction.DOWN;
          case Direction.DOWN: return Direction.UP;
          case Direction.LEFT: return Direction.RIGHT;
          case Direction.RIGHT: return Direction.LEFT;
        }
      };

      const generateLevel = (levelNumber) => {
        const config = getLevelConfig(levelNumber);
        const gridSize = config.size;
        const cats = [];
        const occupied = new Set();

        const markOccupied = (x, y) => occupied.add(`${x},${y}`);
        const isOccupied = (x, y) => occupied.has(`${x},${y}`);

        const totalCells = gridSize * gridSize;
        const maxEmpty = 10;
        const minEmpty = 2;
        const emptySlots = Math.floor(Math.random() * (maxEmpty - minEmpty + 1)) + minEmpty;
        
        const targetCatCount = Math.floor((totalCells - emptySlots) / 2);

        let allCells = [];
        for (let y = 0; y < gridSize; y++) {
          for (let x = 0; x < gridSize; x++) {
            allCells.push({x, y});
          }
        }
        
        const centerX = gridSize / 2;
        const centerY = gridSize / 2;
        allCells.sort((a, b) => Math.random() - 0.5); 
        allCells.sort((a, b) => {
          const distA = Math.hypot(a.x - centerX, a.y - centerY);
          const distB = Math.hypot(b.x - centerX, b.y - centerY);
          return distA - distB; 
        });

        for (const cell of allCells) {
          if (cats.length >= targetCatCount) break;
          if (isOccupied(cell.x, cell.y)) continue;

          const directions = [Direction.UP, Direction.DOWN, Direction.LEFT, Direction.RIGHT];
          for (let i = directions.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [directions[i], directions[j]] = [directions[j], directions[i]];
          }

          for (const dir of directions) {
            const delta = getDelta(dir);
            const tailX = cell.x - delta.dx;
            const tailY = cell.y - delta.dy;

            if (isValid(tailX, tailY, gridSize) && !isOccupied(tailX, tailY)) {
              const isBomb = Math.random() < config.bombChance;
              const availableSkins = CAT_SKINS.slice(0, config.skinCount);
              const skin = availableSkins[Math.floor(Math.random() * availableSkins.length)];

              const oppositeDir = getOppositeDir(dir);

              cats.push({
                id: genId(),
                x: tailX,
                y: tailY,
                direction: oppositeDir,
                type: isBomb ? CatType.BOMB : CatType.NORMAL,
                timer: isBomb ? BOMB_TIME_SECONDS : undefined,
                color: skin,
                isExited: false,
                isMoving: false,
              });

              markOccupied(cell.x, cell.y);
              markOccupied(tailX, tailY);
              break; 
            }
          }
        }

        cats.sort((a, b) => (a.y - b.y) || (a.x - b.x));

        return {
          cats,
          gridSize,
          level: levelNumber,
          unlockedMessage: config.unlockMsg
        };
      };

      const shuffleCats = (currentCats, gridSize) => {
        const activeCats = currentCats.filter(c => !c.isExited);
        const exitedCats = currentCats.filter(c => c.isExited);
        
        const newActiveCats = [];
        const occupied = new Set();
        const markOccupied = (x, y) => occupied.add(`${x},${y}`);
        const isOccupied = (x, y) => occupied.has(`${x},${y}`);
        const isValid = (x, y) => x >= 0 && x < gridSize && y >= 0 && y < gridSize;

        let allCells = [];
        for (let y = 0; y < gridSize; y++) {
          for (let x = 0; x < gridSize; x++) {
            allCells.push({x, y});
          }
        }
        allCells.sort(() => Math.random() - 0.5);

        for (const oldCat of activeCats) {
          let placed = false;
          for (const cell of allCells) {
            if (isOccupied(cell.x, cell.y)) continue;

            const directions = [Direction.UP, Direction.DOWN, Direction.LEFT, Direction.RIGHT];
            directions.sort(() => Math.random() - 0.5);

            for (const dir of directions) {
              const delta = getDelta(dir);
              const tailX = cell.x - delta.dx;
              const tailY = cell.y - delta.dy;

              if (isValid(tailX, tailY) && !isOccupied(tailX, tailY)) {
                newActiveCats.push({
                  ...oldCat,
                  x: cell.x,
                  y: cell.y,
                  direction: dir,
                  isMoving: false
                });
                markOccupied(cell.x, cell.y);
                markOccupied(tailX, tailY);
                placed = true;
                break;
              }
            }
            if (placed) break;
          }
        }

        const result = [...exitedCats, ...newActiveCats];
        result.sort((a, b) => (a.y - b.y) || (a.x - b.x));
        return result;
      };

      // --- COMPONENT: CAT ---

      const Cat = ({ cat, cellSize, gap, onClick, isHint }) => {
        const { x, y, direction, color, type, timer, isExited } = cat;

        const left = x * (cellSize + gap);
        const top = y * (cellSize + gap);
        const isBomb = type === CatType.BOMB;
        const width = cellSize;
        const height = (cellSize * 2) + gap;
        const REF_SIZE = 48;
        const REF_GAP = 8;
        const REF_HEIGHT = (REF_SIZE * 2) + REF_GAP;
        const scale = cellSize / REF_SIZE;

        const transitionClass = isExited ? 'duration-1000 ease-in' : 'duration-300 ease-in-out';

        const wrapperStyle = {
          transform: `translate(${left}px, ${top}px)`,
          width: `${width}px`,
          height: `${width}px`,
          zIndex: isExited ? 9999 : (Math.floor(y) * 10 + Math.floor(x)), 
        };

        const rotationStyle = {
          width: `${width}px`,
          height: `${height}px`,
          transformOrigin: `50% ${ (width/2) / height * 100 }%`,
        };

        return (
          <div
            className={`absolute transition-all ${transitionClass} z-10 will-change-transform`}
            style={wrapperStyle}
          >
            <div 
              className={`absolute top-0 left-0 ${getRotationClass(direction)} transition-transform duration-300 cursor-pointer hover:scale-105`}
              style={rotationStyle}
              onClick={(e) => {
                e.stopPropagation();
                onClick(cat.id);
              }}
            >
              <div 
                 style={{
                   width: REF_SIZE,
                   height: REF_HEIGHT,
                   transform: `scale(${scale})`,
                   transformOrigin: 'top left',
                 }}
              >
                {isHint && !isExited && (
                  <div className="absolute inset-0 rounded-full border-4 border-red-500 hint-ring w-[95%] h-[98%] mx-auto z-0 pointer-events-none"></div>
                )}

                <div className={`w-[90%] h-[95%] mx-auto ${isBomb ? 'bg-red-500' : color} rounded-full shadow-[0_4px_0_rgba(0,0,0,0.15)] relative flex flex-col items-center border-2 border-black/5 overflow-hidden ${isHint ? 'animate-wiggle' : ''} z-10`}>
                  
                  {/* Head */}
                  <div className="w-full h-[45%] relative flex justify-center">
                      <div className={`absolute -top-1 left-1 w-5 h-5 ${isBomb ? 'bg-red-500' : color} rounded-md rotate-[20deg] border-2 border-transparent border-t-black/5 border-l-black/5`}></div>
                      <div className={`absolute -top-1 right-1 w-5 h-5 ${isBomb ? 'bg-red-500' : color} rounded-md -rotate-[20deg] border-2 border-transparent border-t-black/5 border-r-black/5`}></div>

                      <div className="flex flex-col items-center mt-5 z-10">
                          <div className="flex space-x-2.5">
                              <div className="w-3.5 h-3.5 bg-slate-900 rounded-full relative overflow-hidden">
                                <div className="absolute top-1 right-1 w-1.5 h-1.5 bg-white rounded-full"></div>
                              </div>
                              <div className="w-3.5 h-3.5 bg-slate-900 rounded-full relative overflow-hidden">
                                <div className="absolute top-1 right-1 w-1.5 h-1.5 bg-white rounded-full"></div>
                              </div>
                          </div>
                          
                          <div className="flex flex-col items-center -mt-0.5">
                            <div className="w-2.5 h-1.5 bg-pink-400 rounded-full"></div>
                            <div className="w-4 h-2 border-b-2 border-slate-900/20 rounded-full -mt-1"></div>
                          </div>
                      </div>

                      <div className="absolute top-8 -left-1 w-5 h-0.5 bg-black/10 rotate-12"></div>
                      <div className="absolute top-9 -left-1 w-5 h-0.5 bg-black/10 -rotate-6"></div>
                      <div className="absolute top-8 -right-1 w-5 h-0.5 bg-black/10 -rotate-12"></div>
                      <div className="absolute top-9 -right-1 w-5 h-0.5 bg-black/10 rotate-6"></div>
                  </div>

                  {/* Body */}
                  <div className="w-full h-[55%] relative flex flex-col items-center justify-end pb-3">
                      <div className="absolute top-2 w-12 h-16 bg-black/5 rounded-full blur-[1px]"></div>

                      <div className="absolute bottom-2 w-full flex justify-between px-4 z-10">
                        <div className="w-3.5 h-3.5 bg-white/40 rounded-full"></div>
                        <div className="w-3.5 h-3.5 bg-white/40 rounded-full"></div>
                      </div>
                      
                      <div className="absolute bottom-12 w-full flex justify-between px-5 opacity-80">
                        <div className="w-3 h-3 bg-white/30 rounded-full"></div>
                        <div className="w-3 h-3 bg-white/30 rounded-full"></div>
                      </div>

                      <div className={`absolute -bottom-2 w-4 h-8 ${isBomb ? 'bg-red-500' : color} rounded-full z-0 border border-black/5`}></div>
                  </div>

                  {isBomb && (
                    <div className="absolute top-2 left-1/2 -translate-x-1/2 bg-slate-900 text-white text-[10px] font-bold px-1.5 py-0.5 rounded-full flex items-center shadow-md whitespace-nowrap z-20 border border-white/20 animate-pulse">
                      <Timer size={10} className="mr-0.5" />
                      {timer}s
                    </div>
                  )}
                </div>
              </div>
            </div>
          </div>
        );
      };

      // --- APP COMPONENT ---

      const BGM_URL = "https://cdn.pixabay.com/audio/2022/03/24/audio_c8c8a73467.mp3";

      const PRAISE_MESSAGES = [
        "Purr-fect!",
        "Pawsome Job!",
        "Meow-velous!",
        "Cat-tastic!",
        "You're the Cat's Whiskers!",
        "Fur-nominal!",
        "Clawsome!"
      ];

      const App = () => {
        const [level, setLevel] = useState(() => {
          if (typeof window !== 'undefined' && window.localStorage) {
            const saved = localStorage.getItem('meow_parking_level');
            if (saved) {
              const parsed = parseInt(saved, 10);
              return !isNaN(parsed) && parsed > 0 ? parsed : 1;
            }
          }
          return 1;
        });

        const [cats, setCats] = useState([]);
        const [gridSize, setGridSize] = useState(10);
        const [gameState, setGameState] = useState(GameState.START_MENU);
        const [isSoundEnabled, setIsSoundEnabled] = useState(true);
        const [isAnimating, setIsAnimating] = useState(false);
        const [toastMessage, setToastMessage] = useState(null);
        const [scale, setScale] = useState(1);
        
        const [startTime, setStartTime] = useState(0);
        const [levelDuration, setLevelDuration] = useState(0);
        const [isPaused, setIsPaused] = useState(false);
        const audioRef = useRef(null);
        const [activeTool, setActiveTool] = useState('NONE');
        const [hintCatId, setHintCatId] = useState(null);
        const [interactionTrigger, setInteractionTrigger] = useState(0);

        useEffect(() => {
          if (typeof window !== 'undefined' && window.localStorage) {
            localStorage.setItem('meow_parking_level', level.toString());
          }
        }, [level]);

        useEffect(() => {
          const tg = window.Telegram?.WebApp;
          if (tg) {
            tg.ready();
            tg.expand();
          }
        }, []);

        const startLevel = useCallback((lvl) => {
          try {
            const levelData = generateLevel(lvl);
            setCats(levelData.cats);
            setGridSize(levelData.gridSize);
            setGameState(GameState.PLAYING);
            setIsAnimating(false);
            setActiveTool('NONE');
            setStartTime(Date.now());
            setIsPaused(false);
            setHintCatId(null);
            setInteractionTrigger(prev => prev + 1);

            if (levelData.unlockedMessage) {
              setToastMessage(levelData.unlockedMessage);
              setTimeout(() => setToastMessage(null), 3000);
            }
          } catch (e) {
            console.error("Failed to generate level", e);
            setGameState(GameState.START_MENU);
          }
        }, []);

        useEffect(() => {
          const audio = audioRef.current;
          if (!audio) return;
          audio.volume = 0.3;

          const playAudio = () => {
            audio.play().catch(err => {
              console.log("Autoplay prevented:", err);
            });
          };

          if (isSoundEnabled && gameState !== GameState.START_MENU) {
            playAudio();
            const handleFirstInteraction = () => {
              if (isSoundEnabled && audio.paused) {
                audio.play().catch(() => {});
              }
              document.removeEventListener('click', handleFirstInteraction);
              document.removeEventListener('touchstart', handleFirstInteraction);
            };

            document.addEventListener('click', handleFirstInteraction);
            document.addEventListener('touchstart', handleFirstInteraction);

            return () => {
              document.removeEventListener('click', handleFirstInteraction);
              document.removeEventListener('touchstart', handleFirstInteraction);
            };
          } else {
            audio.pause();
          }
        }, [isSoundEnabled, gameState]);

        useEffect(() => {
          if (gameState !== GameState.PLAYING || isPaused) return;

          const interval = setInterval(() => {
            setCats(currentCats => {
              let hasChanges = false;
              let gameOver = false;

              const nextCats = currentCats.map(cat => {
                if (cat.type === CatType.BOMB && !cat.isExited && cat.timer !== undefined) {
                  if (cat.timer <= 0) {
                    gameOver = true;
                    return cat;
                  }
                  hasChanges = true;
                  return { ...cat, timer: cat.timer - 1 };
                }
                return cat;
              });

              if (gameOver) setGameState(GameState.LOST);
              return hasChanges ? nextCats : currentCats;
            });
          }, 1000);

          return () => clearInterval(interval);
        }, [gameState, isPaused]);

        useEffect(() => {
          if (gameState !== GameState.PLAYING || isPaused || isAnimating || activeTool !== 'NONE') {
              setHintCatId(null);
              return;
          }
          setHintCatId(null);

          const timer = setTimeout(() => {
              const activeCats = cats.filter(c => !c.isExited);
              const validCat = activeCats.find(cat => {
                  const { dx, dy } = getDelta(cat.direction);
                  for (let step = 1; step <= gridSize; step++) {
                       const nx = cat.x + dx * step;
                       const ny = cat.y + dy * step;
                       if (nx < 0 || nx >= gridSize || ny < 0 || ny >= gridSize) return true;
                       
                       const isBlocked = activeCats.some(other => {
                          if (other.id === cat.id) return false;
                          if (Math.round(other.x) === nx && Math.round(other.y) === ny) return true;
                          const od = getDelta(other.direction);
                          if (Math.round(other.x - od.dx) === nx && Math.round(other.y - od.dy) === ny) return true;
                          return false;
                       });
                       if (isBlocked) return false;
                  }
                  return false;
              });

              if (validCat) {
                  setHintCatId(validCat.id);
              }
          }, 10000);

          return () => clearTimeout(timer);
        }, [cats, gameState, isPaused, isAnimating, activeTool, gridSize, interactionTrigger]);

        useEffect(() => {
          if (gameState !== GameState.PLAYING) return;
          const activeCats = cats.filter(c => !c.isExited);
          
          if (cats.length > 0 && activeCats.length === 0) {
            const durationSec = (Date.now() - startTime) / 1000;
            setLevelDuration(durationSec);

            const timer = setTimeout(() => {
              setGameState(GameState.WON);
            }, 500);
            return () => clearTimeout(timer);
          }
        }, [cats, gameState, startTime]);

        const handleToolShuffle = () => {
          if (gameState !== GameState.PLAYING || isAnimating || isPaused) return;
          setInteractionTrigger(p => p + 1);
          setIsAnimating(true);
          const shuffled = shuffleCats(cats, gridSize);
          setCats(shuffled);
          setActiveTool('NONE');
          setTimeout(() => setIsAnimating(false), 500);
        };

        const handleToolRemove = (id) => {
          setInteractionTrigger(p => p + 1);
          setCats(prev => prev.filter(c => c.id !== id));
          setActiveTool('NONE');
          setToastMessage("Meow! Removed!");
          setTimeout(() => setToastMessage(null), 1000);
        };

        const handleGlobalFlip = () => {
          if (gameState !== GameState.PLAYING || isAnimating || isPaused) return;
          setInteractionTrigger(p => p + 1);
          setIsAnimating(true);

          setCats(prev => prev.map(cat => {
            if (cat.isExited) return cat;

            let newDir = Direction.UP;
            if (cat.direction === Direction.UP) newDir = Direction.DOWN;
            else if (cat.direction === Direction.DOWN) newDir = Direction.UP;
            else if (cat.direction === Direction.LEFT) newDir = Direction.RIGHT;
            else if (cat.direction === Direction.RIGHT) newDir = Direction.LEFT;

            const delta = getDelta(cat.direction);
            const newHeadX = cat.x - delta.dx;
            const newHeadY = cat.y - delta.dy;

            return {
              ...cat,
              direction: newDir,
              x: newHeadX,
              y: newHeadY
            };
          }));

          setActiveTool('NONE');
          setToastMessage("All cats flipped!");
          setTimeout(() => {
              setToastMessage(null);
              setIsAnimating(false);
          }, 600);
        };

        const handleCatClick = useCallback((id) => {
          if (gameState !== GameState.PLAYING || isAnimating || isPaused) return;

          setInteractionTrigger(p => p + 1);

          if (activeTool === 'REMOVE') {
            handleToolRemove(id);
            return;
          }

          const catIndex = cats.findIndex(c => c.id === id);
          if (catIndex === -1) return;
          
          const cat = cats[catIndex];
          if (cat.isExited) return;

          setIsAnimating(true);

          const { dx, dy } = getDelta(cat.direction);
          let targetX = cat.x;
          let targetY = cat.y;
          let willExit = false;

          for (let step = 1; step <= gridSize; step++) {
            const nextX = cat.x + (dx * step);
            const nextY = cat.y + (dy * step);

            if (nextX < 0 || nextX >= gridSize || nextY < 0 || nextY >= gridSize) {
              willExit = true;
              targetX = nextX + (dx * (gridSize * 2.5)); 
              targetY = nextY + (dy * (gridSize * 2.5));
              break;
            }

            const obstacle = cats.find(c => {
              if (c.id === id || c.isExited) return false;
              if (Math.round(c.x) === nextX && Math.round(c.y) === nextY) return true;
              const { dx: tdx, dy: tdy } = getDelta(c.direction);
              const tailX = c.x - tdx;
              const tailY = c.y - tdy;
              if (Math.round(tailX) === nextX && Math.round(tailY) === nextY) return true;
              return false;
            });

            if (obstacle) {
              targetX = nextX - dx;
              targetY = nextY - dy;
              willExit = false;
              break;
            }

            targetX = nextX;
            targetY = nextY;
          }

          if (targetX === cat.x && targetY === cat.y) {
             setIsAnimating(false);
             return;
          }

          const newCats = [...cats];
          newCats[catIndex] = {
            ...cat,
            x: targetX,
            y: targetY,
            isExited: willExit,
            isMoving: true,
          };

          setCats(newCats);
          setTimeout(() => setIsAnimating(false), 300);

        }, [cats, gameState, isAnimating, gridSize, activeTool, isPaused]);

        const boardSizePx = gridSize * (CELL_SIZE_PX + GAP_PX) - GAP_PX;
        const boardPadding = 40;
        const boardTotalSize = boardSizePx + boardPadding;

        useEffect(() => {
          const handleResize = () => {
            const rotatedWidth = boardTotalSize * Math.sqrt(2);
            const safeMargin = 16; 
            const availableWidth = window.innerWidth - safeMargin;
            const availableHeight = window.innerHeight - 200; 

            const scaleX = availableWidth / rotatedWidth;
            const scaleY = availableHeight / rotatedWidth;
            const newScale = Math.min(1.2, scaleX, scaleY);
            setScale(newScale);
          };

          handleResize();
          window.addEventListener('resize', handleResize);
          return () => window.removeEventListener('resize', handleResize);
        }, [boardTotalSize]);

        const encouragingMessage = useMemo(() => {
           return PRAISE_MESSAGES[Math.floor(Math.random() * PRAISE_MESSAGES.length)];
        }, [level, gameState]);

        const handleStartGame = () => {
          startLevel(level);
          if (audioRef.current && isSoundEnabled && audioRef.current.paused) {
            audioRef.current.play().catch(() => {});
          }
        };

        const handleNextLevel = () => {
          const nextLevel = level + 1;
          setLevel(nextLevel);
          setCats([]);
          startLevel(nextLevel);
        };
        
        const handleHome = () => {
          setIsPaused(true);
        };

        const confirmHome = () => {
          setGameState(GameState.START_MENU);
          setIsPaused(false);
        };

        const resumeGame = () => {
          setIsPaused(false);
        };

        return (
          <div className={`relative w-full h-screen bg-grass flex flex-col items-center overflow-hidden ${activeTool !== 'NONE' ? 'cursor-crosshair' : ''}`}>
            
            <audio ref={audioRef} src={BGM_URL} loop />

            {gameState === GameState.START_MENU && (
              <div className="absolute inset-0 z-[100] bg-grass flex flex-col items-center justify-center p-6">
                 <div className="bg-white/90 backdrop-blur-md rounded-3xl p-10 shadow-2xl flex flex-col items-center max-w-sm w-full border-4 border-green-500 animate-bounce-in">
                    <div className="mb-6 relative">
                       <CatIcon size={80} className="text-orange-400 drop-shadow-lg" />
                       <Sparkles size={40} className="text-yellow-400 absolute -top-4 -right-4 animate-pulse" />
                    </div>
                    <h1 className="text-4xl font-black text-slate-800 text-center mb-2 leading-tight">Meow<br/>Parking Jam</h1>
                    <p className="text-slate-600 mb-8 font-medium text-center">Help the kitties escape!</p>
                    
                    <button 
                      onClick={handleStartGame}
                      className="w-full py-4 bg-gradient-to-r from-green-500 to-emerald-600 text-white rounded-2xl font-bold text-xl shadow-lg shadow-green-300 transform transition hover:scale-105 active:scale-95 flex items-center justify-center gap-3"
                    >
                      <Play fill="currentColor" />
                      Play Now {level > 1 && <span className="text-sm opacity-80">(Lvl {level})</span>}
                    </button>

                    <div className="mt-6 flex gap-4">
                       <button 
                          onClick={() => setIsSoundEnabled(!isSoundEnabled)}
                          className="p-3 rounded-full bg-slate-100 text-slate-500 hover:bg-slate-200 transition"
                        >
                         {isSoundEnabled ? <Volume2 size={24}/> : <VolumeX size={24}/>}
                       </button>
                    </div>
                 </div>
                 <div className="absolute bottom-8 text-green-800/60 font-bold text-sm">
                   v1.2.6
                 </div>
              </div>
            )}

            <div className="absolute top-0 w-full p-4 flex justify-between items-start z-50 pointer-events-none">
              <div className="bg-white/90 backdrop-blur-sm border-2 border-green-500 rounded-2xl px-4 py-2 shadow-lg flex items-center gap-2 pointer-events-auto">
                 <Award className="text-yellow-500" />
                 <span className="font-bold text-green-800 text-lg">Level {level}</span>
              </div>

              <div className="flex gap-2 pointer-events-auto">
                   <button 
                    onClick={handleHome}
                    title="Pause & Home"
                    className="bg-white/90 p-2 rounded-full shadow-lg border-2 border-green-500 text-green-700 hover:bg-green-50 transition"
                  >
                     <Home size={24}/>
                  </button>
                  <button 
                    onClick={() => setIsSoundEnabled(!isSoundEnabled)}
                    className="bg-white/90 p-2 rounded-full shadow-lg border-2 border-green-500 text-green-700 hover:bg-green-50 transition"
                  >
                     {isSoundEnabled ? <Volume2 size={24}/> : <VolumeX size={24}/>}
                  </button>
                   <button 
                    onClick={() => startLevel(level)}
                    className="bg-white/90 p-2 rounded-full shadow-lg border-2 border-green-500 text-green-700 hover:bg-green-50 transition"
                  >
                     <RotateCcw size={24}/>
                  </button>
              </div>
            </div>

            {toastMessage && (
              <div className="absolute top-24 z-50 animate-bounce-in pointer-events-none w-full flex justify-center px-4">
                <div className="bg-yellow-100 border-2 border-yellow-400 text-yellow-800 px-6 py-3 rounded-full shadow-xl font-bold flex items-center gap-2 text-sm sm:text-base">
                   <span className="text-center">{toastMessage}</span>
                </div>
              </div>
            )}

            <div className="flex-1 flex items-center justify-center w-full">
              <div 
                className="relative flex items-center justify-center transition-transform duration-300 ease-out"
                style={{ transform: `scale(${scale})` }}
              >
                <div 
                    className="relative bg-green-200/50 rounded-xl shadow-2xl border-4 border-green-600/30 rotate-45 transition-all duration-500"
                    style={{ width: boardTotalSize, height: boardTotalSize, padding: 20 }}
                >
                  <div className="relative transition-all duration-500" style={{ width: boardSizePx, height: boardSizePx }}>
                     {Array.from({ length: gridSize * gridSize }).map((_, i) => {
                       const x = i % gridSize;
                       const y = Math.floor(i / gridSize);
                       return (
                         <div
                            key={i}
                            className="absolute bg-black/5 rounded-lg"
                            style={{
                              width: CELL_SIZE_PX,
                              height: CELL_SIZE_PX,
                              left: x * (CELL_SIZE_PX + GAP_PX),
                              top: y * (CELL_SIZE_PX + GAP_PX),
                            }}
                         />
                       );
                     })}

                     {cats.map(cat => (
                       <div key={cat.id} className={`${activeTool === 'REMOVE' ? 'hover:opacity-50' : ''}`}>
                         <Cat 
                            cat={cat} 
                            cellSize={CELL_SIZE_PX} 
                            gap={GAP_PX} 
                            onClick={handleCatClick} 
                            isHint={cat.id === hintCatId}
                         />
                       </div>
                     ))}
                  </div>
                </div>
              </div>
            </div>

            <div className="w-full pb-8 pt-2 px-6 flex justify-center items-end gap-4 z-50">
                <div className="flex flex-col items-center gap-1">
                  <button 
                    onClick={() => setActiveTool(activeTool === 'REMOVE' ? 'NONE' : 'REMOVE')}
                    className={`p-4 rounded-2xl shadow-xl border-b-4 transition-all active:scale-95 ${
                      activeTool === 'REMOVE' 
                      ? 'bg-red-500 border-red-700 text-white translate-y-1' 
                      : 'bg-white border-slate-200 text-slate-600 hover:bg-red-50'
                    }`}
                  >
                    <Trash2 size={28} />
                  </button>
                  <span className="text-xs font-bold text-white drop-shadow-md">Remove</span>
                </div>

                <div className="flex flex-col items-center gap-1 mb-4">
                  <button 
                    onClick={handleToolShuffle}
                    disabled={isAnimating || isPaused}
                    className="p-5 rounded-full shadow-2xl border-b-4 bg-gradient-to-tr from-blue-400 to-blue-500 border-blue-700 text-white transition-all hover:scale-105 active:scale-95 active:border-b-0"
                  >
                    <Shuffle size={32} />
                  </button>
                  <span className="text-xs font-bold text-white drop-shadow-md">Shuffle</span>
                </div>

                <div className="flex flex-col items-center gap-1">
                   <button 
                    onClick={handleGlobalFlip}
                    disabled={isAnimating || isPaused}
                    className={`p-4 rounded-2xl shadow-xl border-b-4 bg-white border-slate-200 text-slate-600 hover:bg-purple-50 transition-all active:scale-95`}
                  >
                    <Repeat size={28} />
                  </button>
                  <span className="text-xs font-bold text-white drop-shadow-md">Flip All</span>
                </div>
            </div>
            
            {activeTool === 'REMOVE' && (
               <div className="absolute bottom-32 bg-slate-900/80 text-white px-6 py-2 rounded-full font-bold animate-pulse pointer-events-none z-50">
                  Tap a cat to remove it!
               </div>
            )}

            {isPaused && (
              <div className="absolute inset-0 z-[60] bg-black/60 flex items-center justify-center p-4">
                <div className="bg-white rounded-3xl p-8 max-w-sm w-full text-center shadow-2xl animate-bounce-in relative">
                    <button onClick={resumeGame} className="absolute top-4 right-4 text-slate-400 hover:text-slate-600">
                      <X size={24} />
                    </button>
                   <h2 className="text-3xl font-black text-slate-800 mb-6">Game Paused</h2>
                   <div className="flex flex-col gap-3">
                     <button
                        onClick={resumeGame}
                        className="w-full py-4 rounded-xl font-bold text-white text-xl bg-gradient-to-r from-blue-400 to-blue-600 shadow-lg shadow-blue-300 transition transform hover:scale-105 active:scale-95"
                     >
                        Resume
                     </button>
                     <button
                        onClick={confirmHome}
                        className="w-full py-4 rounded-xl font-bold text-slate-600 text-xl bg-slate-100 border-2 border-slate-200 shadow-md transition transform hover:bg-slate-200 active:scale-95"
                     >
                        Quit to Home
                     </button>
                   </div>
                </div>
              </div>
            )}

            {(gameState === GameState.WON || gameState === GameState.LOST) && (
              <div className="absolute inset-0 z-[60] bg-black/60 flex items-center justify-center p-4">
                <div className="bg-white rounded-3xl p-8 max-w-sm w-full text-center shadow-2xl animate-bounce-in relative overflow-hidden">
                   
                   {gameState === GameState.WON && (
                     <div className="absolute top-0 left-0 w-full h-full pointer-events-none opacity-20">
                        <div className="absolute top-10 left-10 text-yellow-500 animate-spin-slow"><Sparkles size={40}/></div>
                        <div className="absolute bottom-10 right-10 text-yellow-500 animate-spin-slow"><Sparkles size={40}/></div>
                     </div>
                   )}

                   <div className="text-6xl mb-4 animate-bounce">
                      {gameState === GameState.WON ? 'ðŸŽ‰' : 'ðŸ˜¿'}
                   </div>
                   
                   <h2 className="text-3xl font-black text-slate-800 mb-2">
                     {gameState === GameState.WON ? 'Level Cleared!' : 'Game Over!'}
                   </h2>

                   {gameState === GameState.WON && (
                     <div className="flex flex-col gap-1 mb-6">
                       <div className="text-xl font-bold text-purple-600 animate-pulse">
                          {encouragingMessage}
                       </div>
                       <div className="inline-flex items-center justify-center gap-2 text-slate-500 bg-slate-100 rounded-full px-4 py-1 mx-auto mt-2">
                          <Clock size={16} />
                          <span className="font-bold text-lg">{Math.floor(levelDuration)}s</span>
                       </div>
                     </div>
                   )}
                   
                   {gameState === GameState.LOST && (
                      <p className="text-slate-600 mb-6 text-sm">
                         The bomb cat ran out of time!
                      </p>
                   )}
                   
                   <button
                      onClick={() => {
                        if (gameState === GameState.WON) {
                          handleNextLevel();
                        } else {
                          startLevel(level);
                        }
                      }}
                      className={`w-full py-4 rounded-xl font-bold text-white text-xl shadow-lg transition transform hover:scale-105 active:scale-95 ${
                        gameState === GameState.WON 
                          ? 'bg-gradient-to-r from-green-400 to-green-600 shadow-green-300' 
                          : 'bg-gradient-to-r from-red-400 to-red-600 shadow-red-300'
                      }`}
                   >
                      {gameState === GameState.WON ? 'Next Level' : 'Try Again'}
                   </button>
                   
                   <button
                      onClick={confirmHome}
                      className="mt-4 text-slate-400 font-bold hover:text-slate-600 text-sm underline"
                   >
                     Back to Home
                   </button>
                </div>
              </div>
            )}

            <div className="absolute top-16 left-4 text-green-800/60 text-xs font-bold pointer-events-none">
               Density: {Math.round((cats.length * 2) / (gridSize * gridSize) * 100)}%
            </div>
          </div>
        );
      };

      // --- MOUNT ---
      const rootElement = document.getElementById('root');
      if (rootElement) {
        const root = createRoot(rootElement);
        root.render(<App />);
      }
    </script>
  </body>
</html>